<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Location History Converter</title>
    <!-- Include Turf.js for spatial operations -->
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <!-- Include the geo-enrichment module -->
    <script src="geo-enrichment.js" defer></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3 {
            color: #1a73e8;
        }
        h1 {
            border-bottom: 2px solid #f1f1f1;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .card {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .info-box {
            background-color: #f8f9fa;
            border-left: 4px solid #1a73e8;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .warning {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
        }
        .success {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
        }
        button {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #1557b0;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #fileInput {
            display: none;
        }
        .file-input-label {
            display: inline-block;
            background-color: #1a73e8;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .file-input-label:hover {
            background-color: #1557b0;
        }
        #status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .progress-container {
            width: 100%;
            background-color: #f1f1f1;
            border-radius: 4px;
            margin: 10px 0;
        }
        .progress-bar {
            height: 20px;
            background-color: #4CAF50;
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s;
            text-align: center;
            line-height: 20px;
            color: white;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f1f1f1;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #preview {
            margin-top: 20px;
            max-height: 400px;
            overflow: auto;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
        }
        .toggle-section {
            cursor: pointer;
        }
        .toggle-section::after {
            content: " ▼";
            font-size: 0.8em;
        }
        .toggle-section.collapsed::after {
            content: " ►";
        }
        .collapsible {
            display: block;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .collapsible.collapsed {
            max-height: 0;
            display: none;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active {
            background-color: #fff;
            border-color: #ddd;
            border-bottom: 2px solid #1a73e8;
            font-weight: bold;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <h1>Google Location History Converter</h1>
    <div class="info-box">
        <p>This tool converts your Google Location History JSON files to CSV format. <strong>All processing happens in your browser</strong> - your data never leaves your computer. You can use this for:</p>
        <ul>
            <li>Converting standard/raw Google Takeout location history files</li>
            <li>Processing activity segment data (walking, cycling, driving, etc.)</li>
            <li>Exporting in formats suitable for QGIS, Google Earth, or spreadsheet analysis</li>
        </ul>
    </div>
    
    <div class="container">
        <div class="card">
            <h2>Step 1: Select Your Location History JSON File</h2>
            <p>Select the JSON file from your Google Takeout download (typically named <code>Location History.json</code> or <code>Records.json</code>).</p>
            <div>
                <label for="fileInput" class="file-input-label">Choose File</label>
                <input type="file" id="fileInput" accept=".json">
                <span id="fileName"></span>
            </div>
            <div id="status"></div>
            <div class="progress-container" style="display: none;">
                <div class="progress-bar" id="progressBar">0%</div>
            </div>
        </div>

        <div class="card">
            <h2>Step 2: Configure and Process</h2>
            <div class="info-box">
                <p>Options for processing your data:</p>
                <ul>
                    <li><strong>Complete Location Data:</strong> Export all locations with timestamps, coordinates, and accuracy</li>
                    <li><strong>Activity Data:</strong> Export movement activities (walking, driving, etc.) with distances and durations</li>
                </ul>
            </div>
            
            <div class="action-buttons">
                <button id="processButton" disabled>Process File</button>
                <button id="downloadAllButton" disabled>Download Location History CSV</button>
                <button id="downloadActivitiesButton" disabled>Download Activities CSV</button>
            </div>
            
            <div id="geoDetectionInfo" class="info-box warning" style="margin-top: 15px; display: none;">
                <h3 style="margin-top: 0;">Automatic Municipality Detection</h3>
                <div id="municipalityStatus"></div>
            </div>
        </div>

        <div class="card">
            <h2 class="toggle-section" id="resultsToggle">Results Preview</h2>
            <div class="collapsible" id="resultsSection">
                <div class="tabs">
                    <div class="tab active" data-tab="allLocations">Location History</div>
                    <div class="tab" data-tab="activities">Activity Data</div>
                </div>
                
                <div class="tab-content active" id="allLocations">
                    <div id="previewAll">Select and process a file to see a preview</div>
                </div>
                
                <div class="tab-content" id="activities">
                    <div id="previewActivities">Select and process a file to see a preview</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2 class="toggle-section collapsed" id="instructionsToggle">How to Use the Data</h2>
            <div class="collapsible collapsed" id="instructionsSection">
                <h3>Viewing Your Data in QGIS</h3>
                <ol>
                    <li>Download your CSV file using the "Download" button above</li>
                    <li>Open QGIS and create a new project</li>
                    <li>Go to <strong>Layer > Add Layer > Add Delimited Text Layer</strong></li>
                    <li>Browse to your downloaded CSV file</li>
                    <li>Make sure the following settings are applied:
                        <ul>
                            <li>File format: CSV</li>
                            <li>Record and Field options: select "First record has field names"</li>
                            <li>Geometry definition: select "Point coordinates"</li>
                            <li>X field: select "longitude"</li>
                            <li>Y field: select "latitude"</li>
                        </ul>
                    </li>
                    <li>Click "Add" to load your data as points on the map</li>
                    <li>Right-click the layer and choose "Properties" to style your points</li>
                </ol>
                
                <h3>Understanding the Output</h3>
                <p>The Location History CSV file contains the following columns:</p>
                <table>
                    <tr>
                        <th>Column</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>timestamp</td>
                        <td>Date and time in ISO format (YYYY-MM-DD HH:MM:SS)</td>
                    </tr>
                    <tr>
                        <td>latitude</td>
                        <td>Latitude coordinate</td>
                    </tr>
                    <tr>
                        <td>longitude</td>
                        <td>Longitude coordinate</td>
                    </tr>
                    <tr>
                        <td>country</td>
                        <td>Country name (if detected)</td>
                    </tr>
                    <tr>
                        <td>region</td>
                        <td>Administrative region (if detected)</td>
                    </tr>
                    <tr>
                        <td>province</td>
                        <td>Province or state (if detected)</td>
                    </tr>
                    <tr>
                        <td>municipality</td>
                        <td>Municipality or city (if detected)</td>
                    </tr>
                    <tr>
                        <td>placeID</td>
                        <td>Google's place ID (if available)</td>
                    </tr>
                    <tr>
                        <td>semanticType</td>
                        <td>Location semantic type (e.g., Home, Work)</td>
                    </tr>
                    <tr>
                        <td>probability</td>
                        <td>Probability of the place candidate (topCandidate.probability)</td>
                    </tr>
                    <tr>
                        <td>visitProbability</td>
                        <td>Overall probability of the visit (visit.probability)</td>
                    </tr>
                </table>
                
                <h3>Activity Data Fields</h3>
                <p>The Activities CSV includes additional fields:</p>
                <table>
                    <tr>
                        <th>Column</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>startTime</td>
                        <td>When the activity started</td>
                    </tr>
                    <tr>
                        <td>endTime</td>
                        <td>When the activity ended</td>
                    </tr>
                    <tr>
                        <td>duration_minutes</td>
                        <td>Duration of the activity in minutes</td>
                    </tr>
                    <tr>
                        <td>distance_km</td>
                        <td>Approximate distance traveled in kilometers</td>
                    </tr>
                    <tr>
                        <td>speed_kph</td>
                        <td>Average speed in kilometers per hour</td>
                    </tr>
                    <tr>
                        <td>latitude, longitude</td>
                        <td>Starting coordinates of the activity</td>
                    </tr>
                    <tr>
                        <td>start_lat, start_lng</td>
                        <td>Starting coordinates of the activity</td>
                    </tr>
                    <tr>
                        <td>end_lat, end_lng</td>
                        <td>Ending coordinates of the activity</td>
                    </tr>
                    <tr>
                        <td>activity_type</td>
                        <td>Detected activity (WALKING, CYCLING, IN_VEHICLE)</td>
                    </tr>
                    <tr>
                        <td>activity_probability</td>
                        <td>Confidence level of the activity detection</td>
                    </tr>
                    <tr>
                        <td>municipality</td>
                        <td>Municipality where the activity started</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let processedData = [];
        let activityData = [];
        let fileReader = new FileReader();
        
        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const status = document.getElementById('status');
        const progressBar = document.getElementById('progressBar');
        const processButton = document.getElementById('processButton');
        const downloadAllButton = document.getElementById('downloadAllButton');
        const downloadActivitiesButton = document.getElementById('downloadActivitiesButton');
        const previewAll = document.getElementById('previewAll');
        const previewActivities = document.getElementById('previewActivities');
        const geoDetectionInfo = document.getElementById('geoDetectionInfo');
        const municipalityStatus = document.getElementById('municipalityStatus');

        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // File selection
            fileInput.addEventListener('change', handleFileSelect);
            
            // Button actions
            processButton.addEventListener('click', processFile);
            downloadAllButton.addEventListener('click', () => downloadCSV(processedData, 'location-history.csv'));
            downloadActivitiesButton.addEventListener('click', () => downloadCSV(activityData, 'location-activity-data.csv'));
            
            // Toggle sections
            document.getElementById('resultsToggle').addEventListener('click', function() {
                toggleSection('resultsSection', 'resultsToggle');
            });
            
            document.getElementById('instructionsToggle').addEventListener('click', function() {
                toggleSection('instructionsSection', 'instructionsToggle');
            });
            
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // Update tab active state
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update content visibility
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Initialize geo-enrichment functionality
            geoDetectionInfo.style.display = 'block';
            
            // Using the extracted geo-enrichment module
            // Safely check if the geo-enrichment module is loaded
            if (window.geoEnrichment && window.geoEnrichment.initGeoEnrichment) {
                window.geoEnrichment.initGeoEnrichment(municipalityStatus);
            } else {
                // Fallback if module isn't loaded yet
                municipalityStatus.textContent = "Waiting for geo-enrichment module to load...";
                
                // Try again after a short delay
                setTimeout(function checkGeoEnrichment() {
                    if (window.geoEnrichment && window.geoEnrichment.initGeoEnrichment) {
                        window.geoEnrichment.initGeoEnrichment(municipalityStatus);
                    } else {
                        municipalityStatus.textContent = "Error: Geo-enrichment module not loaded. Municipality detection disabled.";
                        municipalityStatus.style.color = '#F44336';
                    }
                }, 1000);
            }
        });
        
        /**
         * Handle file selection
         */
        function handleFileSelect(event) {
            const file = event.target.files[0];
            
            if (file) {
                fileName.textContent = file.name;
                status.textContent = 'File selected: ' + file.name;
                status.className = 'info-box';
                processButton.disabled = false;
            } else {
                fileName.textContent = '';
                status.textContent = 'No file selected';
                status.className = 'info-box warning';
                processButton.disabled = true;
            }
            
            // Reset buttons
            downloadAllButton.disabled = true;
            downloadActivitiesButton.disabled = true;
            
            // Reset previews
            previewAll.innerHTML = 'Select and process a file to see a preview';
            previewActivities.innerHTML = 'Select and process a file to see a preview';
        }
        
        /**
         * Process the selected JSON file
         */
        function processFile() {
            const file = fileInput.files[0];
            if (!file) {
                status.textContent = 'Please select a file first.';
                status.className = 'info-box warning';
                return;
            }
            
            // Reset data
            processedData = [];
            activityData = [];
            
            // Update UI
            status.textContent = 'Processing file...';
            status.className = 'info-box';
            document.querySelector('.progress-container').style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            
            // Disable process button during processing
            processButton.disabled = true;
            
            // Start processing
            fileReader.onload = function(event) {
                try {
                    let jsonContent;
                    
                    try {
                        console.log('Parsing JSON file...');
                        jsonContent = JSON.parse(event.target.result);
                        console.log('Successfully parsed JSON');
                    } catch (e) {
                        // For very large files, we might need to handle the JSON manually
                        console.log('Direct parsing failed, attempting stream processing');
                        status.textContent = 'File is too large for direct parsing. Using stream processing...';
                        
                        // Try a manual approach for specific formats
                        const rawContent = event.target.result;
                        if (rawContent.includes('"locations":')) {
                            // Standard Google format with locations array
                            console.log('Found locations array in raw content');
                            const locationsStartIndex = rawContent.indexOf('"locations":') + '"locations":'.length;
                            const locationsEndIndex = rawContent.lastIndexOf(']');
                            const locationsJson = rawContent.substring(locationsStartIndex, locationsEndIndex + 1);
                            
                            try {
                                console.log('Parsing locations array...');
                                const locations = JSON.parse(locationsJson);
                                jsonContent = { locations: locations };
                                console.log('Successfully parsed locations array');
                            } catch (innerErr) {
                                console.error('Failed to parse locations array:', innerErr);
                                throw new Error('Failed to parse locations array: ' + innerErr.message);
                            }
                        } else {
                            console.error('Cannot process this file format:', e.message);
                            throw new Error('Cannot process this file format: ' + e.message);
                        }
                    }
                    
                    // Different Google formats with different structures
                    console.log('Attempting to extract locations...');
                    const locations = extractLocations(jsonContent);
                    
                    if (!locations || !locations.length) {
                        console.error('No locations found in the extracted data');
                        throw new Error('No location data found in the file.');
                    }
                    
                    status.textContent = `Found ${locations.length} location entries. Processing...`;
                    
                    // Process in smaller batches to avoid blocking the UI
                    const batchSize = 1000;
                    const totalBatches = Math.ceil(locations.length / batchSize);
                    
                    let currentBatch = 0;
                    let lastProgressReport = 0;
                    
                    function processBatch() {
                        const startIdx = currentBatch * batchSize;
                        const endIdx = Math.min(startIdx + batchSize, locations.length);
                        
                        for (let i = startIdx; i < endIdx; i++) {
                            const entry = processLocationEntry(locations[i]);
                            if (entry) {
                                processedData.push(entry);
                            }
                        }
                        
                        currentBatch++;
                        
                        // Update progress
                        const progress = Math.floor((currentBatch / totalBatches) * 100);
                        if (progress > lastProgressReport) {
                            progressBar.style.width = progress + '%';
                            progressBar.textContent = progress + '%';
                            lastProgressReport = progress;
                        }
                        
                        if (currentBatch < totalBatches) {
                            // Continue processing
                            setTimeout(processBatch, 0);
                        } else {
                            // Processing complete
                            finishProcessing();
                        }
                    }
                    
                    // Start batch processing
                    setTimeout(processBatch, 0);
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    status.textContent = 'Error processing file: ' + error.message;
                    status.className = 'info-box warning';
                    processButton.disabled = false;
                }
            };
            
            fileReader.onerror = function() {
                status.textContent = 'Error reading file.';
                status.className = 'info-box warning';
                processButton.disabled = false;
            };
            
            fileReader.readAsText(file);
        }
        
        /**
         * Finish processing and update UI
         */
        function finishProcessing() {
            // Process all activity data
            extractActivities();
            
            // Enrich with municipality information if available
            if (window.geoEnrichment && window.geoEnrichment.enrichWithMunicipalities) {
                processedData = window.geoEnrichment.enrichWithMunicipalities(processedData);
                activityData = window.geoEnrichment.enrichWithMunicipalities(activityData);
            } else {
                console.warn("Geo-enrichment module not available - municipality data will not be added");
            }
            
            // Update UI
            progressBar.style.width = '100%';
            progressBar.textContent = '100%';
            
            // Re-enable buttons
            processButton.disabled = false;
            downloadAllButton.disabled = false;
            downloadActivitiesButton.disabled = false;
            
            status.textContent = `Processed ${processedData.length} location entries (${activityData.length} activities).`;
            status.className = 'info-box success';
            
            // Show preview for location data
            showPreview(processedData.slice(0, 100), previewAll);
            
            // Show preview for activity data, even if empty - make sure to display a message
            if (activityData.length > 0) {
                showPreview(activityData.slice(0, 100), previewActivities);
            } else {
                previewActivities.innerHTML = '<div style="padding: 15px; background-color: #fff3e0; border-left: 4px solid #ff9800;">No activity data was found or derived from this file. Try a different file or format.</div>';
            }
            
            // Expand results section
            document.getElementById('resultsSection').classList.remove('collapsed');
            document.getElementById('resultsToggle').classList.remove('collapsed');
        }
        
        /**
         * Extract location data from different Google formats
         */
        function extractLocations(jsonData) {
            console.log('Attempting to extract locations from JSON data');
            console.log('JSON data type:', typeof jsonData);
            console.log('Is array?', Array.isArray(jsonData));
            
            // Check if it's an array of visit objects (new Timeline format)
            if (Array.isArray(jsonData) && jsonData.length > 0 && (jsonData[0].visit || jsonData[0].activity)) {
                console.log('Found Google Timeline format with visit/activity objects');
                const locations = [];
                
                jsonData.forEach(obj => {
                    // Extract visit data (locations)
                    if (obj.visit && obj.visit.topCandidate) {
                        const visit = obj.visit;
                        const topCandidate = visit.topCandidate;
                        
                        // Extract coordinates from placeLocation (format: "geo:lat,lng")
                        if (topCandidate.placeLocation) {
                            const geoMatch = topCandidate.placeLocation.match(/geo:([-\d.]+),([-\d.]+)/);
                            if (geoMatch) {
                                locations.push({
                                    startTime: obj.startTime,
                                    endTime: obj.endTime,
                                    latitude: parseFloat(geoMatch[1]),
                                    longitude: parseFloat(geoMatch[2]),
                                    accuracy: visit.accuracy || '',
                                    semanticType: topCandidate.semanticType || '',
                                    placeId: topCandidate.placeID || '',
                                    probability: topCandidate.probability || '',
                                    hierarchyLevel: visit.hierarchyLevel || '',
                                    visitProbability: visit.probability || ''
                                });
                            }
                        }
                    }
                    
                    // Extract activity data (movements)
                    if (obj.activity) {
                        const activity = obj.activity;
                        
                        // Extract start location
                        const startGeo = extractGeoCoordinates(activity.start);
                        // Extract end location
                        const endGeo = extractGeoCoordinates(activity.end);
                        
                        if (startGeo && endGeo) {
                            // Create an activity entry with all the details
                            locations.push({
                                startTime: obj.startTime,
                                endTime: obj.endTime,
                                // Use start coordinates as the main coordinates
                                latitude: startGeo.lat,
                                longitude: startGeo.lng,
                                // Include activity information
                                activity_type: activity.topCandidate?.type || 'unknown',
                                activity_probability: activity.topCandidate?.probability || '0',
                                // Detailed start/end coordinates
                                start_lat: startGeo.lat,
                                start_lng: startGeo.lng,
                                end_lat: endGeo.lat,
                                end_lng: endGeo.lng,
                                // Distance information
                                distance_meters: activity.distanceMeters || '0',
                                // Flag to identify as an activity record
                                isActivitySegment: true
                            });
                        }
                    }
                });
                
                console.log('Extracted locations from visit/activity objects:', locations.length);
                return locations;
            }
            
            // Check for standard Google Takeout format
            if (jsonData.locations && Array.isArray(jsonData.locations)) {
                console.log('Found standard Google Takeout format with locations array');
                console.log('Number of locations:', jsonData.locations.length);
                return jsonData.locations;
            }
            
            // Check for Google Timeline format with timelineObjects
            if (jsonData.timelineObjects && Array.isArray(jsonData.timelineObjects)) {
                console.log('Found Google Timeline format with timelineObjects');
                console.log('Number of timeline objects:', jsonData.timelineObjects.length);
                const locations = [];
                
                // Extract from activitySegment and placeVisit objects
                jsonData.timelineObjects.forEach(obj => {
                    if (obj.activitySegment) {
                        // Extract start and end locations from activity segments
                        const segment = obj.activitySegment;
                        
                        if (segment.startLocation) {
                            locations.push({
                                timestampMs: segment.duration?.startTimestampMs,
                                latitudeE7: segment.startLocation.latitudeE7,
                                longitudeE7: segment.startLocation.longitudeE7,
                                accuracy: segment.startLocation.accuracy,
                                activity: [
                                    {
                                        type: segment.activityType,
                                        confidence: 100 // Default confidence for activity segments
                                    }
                                ]
                            });
                        }
                        
                        if (segment.endLocation) {
                            locations.push({
                                timestampMs: segment.duration?.endTimestampMs,
                                latitudeE7: segment.endLocation.latitudeE7,
                                longitudeE7: segment.endLocation.longitudeE7,
                                accuracy: segment.endLocation.accuracy,
                                activity: [
                                    {
                                        type: segment.activityType,
                                        confidence: 100 // Default confidence for activity segments
                                    }
                                ]
                            });
                        }
                        
                        // Extract waypoints if available
                        if (segment.waypointPath && Array.isArray(segment.waypointPath.waypoints)) {
                            segment.waypointPath.waypoints.forEach((waypoint, index) => {
                                if (waypoint.latE7 && waypoint.lngE7) {
                                    // Estimate timestamp based on position in the list
                                    const startTime = parseInt(segment.duration?.startTimestampMs || 0);
                                    const endTime = parseInt(segment.duration?.endTimestampMs || 0);
                                    const waypointCount = segment.waypointPath.waypoints.length;
                                    const estimatedTime = startTime + ((endTime - startTime) * (index / waypointCount));
                                    
                                    locations.push({
                                        timestampMs: String(estimatedTime),
                                        latitudeE7: waypoint.latE7,
                                        longitudeE7: waypoint.lngE7,
                                        activity: [
                                            {
                                                type: segment.activityType,
                                                confidence: 100 // Default confidence for waypoints
                                            }
                                        ]
                                    });
                                }
                            });
                        }
                    }
                    
                    if (obj.placeVisit && obj.placeVisit.location) {
                        // Extract location from place visits
                        const visit = obj.placeVisit;
                        locations.push({
                            timestampMs: visit.duration?.startTimestampMs,
                            latitudeE7: visit.location.latitudeE7,
                            longitudeE7: visit.location.longitudeE7,
                            accuracy: visit.location.accuracyMetres
                        });
                    }
                });
                
                console.log('Extracted locations from timeline objects:', locations.length);
                return locations;
            }
            
            // Check for array-based format (some versions of Google data)
            if (Array.isArray(jsonData)) {
                console.log('Found array-based format');
                const locations = jsonData.filter(item => 
                    (item.latitudeE7 || item.latitude) && 
                    (item.longitudeE7 || item.longitude)
                );
                console.log('Number of valid locations in array:', locations.length);
                return locations;
            }
            
            // Log available keys to help debug unknown formats
            console.log('Unknown format. Available top-level keys:', Object.keys(jsonData));
            throw new Error('Unsupported JSON format. Could not find location data.');
        }
        
        /**
         * Extract geo coordinates from a string like "geo:40.338423,-3.777495"
         */
        function extractGeoCoordinates(geoString) {
            if (!geoString) return null;
            
            const geoMatch = geoString.match(/geo:([-\d.]+),([-\d.]+)/);
            if (geoMatch) {
                return {
                    lat: parseFloat(geoMatch[1]),
                    lng: parseFloat(geoMatch[2])
                };
            }
            return null;
        }
        
        /**
         * Process a single location entry into our standardized format
         */
        function processLocationEntry(entry) {
            // Skip entries without coordinates
            if (!entry.latitude && !entry.longitude && !entry.latitudeE7 && !entry.longitudeE7) {
                return null;
            }
            
            // Convert E7 format if needed (Google uses integer E7 format)
            const latitude = entry.latitudeE7 ? (entry.latitudeE7 / 10000000) : 
                             (typeof entry.latitude === 'number' ? entry.latitude : parseFloat(entry.latitude));
            
            const longitude = entry.longitudeE7 ? (entry.longitudeE7 / 10000000) : 
                              (typeof entry.longitude === 'number' ? entry.longitude : parseFloat(entry.longitude));
            
            // Skip invalid coordinates
            if (isNaN(latitude) || isNaN(longitude) || 
                latitude < -90 || latitude > 90 || 
                longitude < -180 || longitude > 180) {
                return null;
            }
            
            // Process timestamps - handle ISO-8601 format
            let timestampStr;
            
            // For the new timeline format with ISO timestamps
            if (entry.startTime) {
                // Use startTime as the main timestamp
                try {
                    const parsedDate = new Date(entry.startTime);
                    if (!isNaN(parsedDate.getTime())) {
                        // Format the timestamp as YYYY-MM-DD HH:MM:SS
                        timestampStr = parsedDate.toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
                    } else {
                        timestampStr = entry.startTime; // Keep original if parsing fails
                    }
                } catch (e) {
                    console.warn('Error parsing startTime:', entry.startTime, e);
                    timestampStr = entry.startTime;
                }
            } 
            // For older formats with millisecond timestamp
            else if (entry.timestampMs) {
                try {
                    const timestamp = new Date(parseInt(entry.timestampMs));
                    timestampStr = timestamp.toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
                } catch (e) {
                    console.warn('Error parsing timestampMs:', entry.timestampMs, e);
                    timestampStr = new Date().toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
                }
            } 
            // Fallback
            else {
                timestampStr = new Date().toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
            }
            
            // Extract activity information
            let activityType = '';
            let activityConfidence = '';
            
            // Handle explicit activity type from the activity entry
            if (entry.activity_type) {
                activityType = entry.activity_type;
                activityConfidence = entry.activity_probability || '';
            }
            // Handle activity array from standard Google format
            else if (entry.activity && entry.activity.length > 0) {
                // Find the most likely activity
                let highestConfidence = -1;
                
                for (const activity of entry.activity) {
                    if (activity.activities && activity.activities.length > 0) {
                        // Standard Google format with activities array
                        for (const subActivity of activity.activities) {
                            if (subActivity.confidence > highestConfidence) {
                                highestConfidence = subActivity.confidence;
                                activityType = subActivity.type;
                                activityConfidence = subActivity.confidence;
                            }
                        }
                    } else if (activity.type) {
                        // Simplified format
                        const confidence = activity.confidence || 100;
                        if (confidence > highestConfidence) {
                            highestConfidence = confidence;
                            activityType = activity.type;
                            activityConfidence = confidence;
                        }
                    }
                }
            }
            
            // Create standardized record with probability fields
            const result = {
                timestamp: timestampStr,
                latitude: latitude.toFixed(6),
                longitude: longitude.toFixed(6),
                country: entry.country || '',
                region: entry.region || '',
                province: entry.province || '',
                municipality: entry.municipality || '',
                placeID: entry.placeId || '',
                semanticType: entry.semanticType || '',
                probability: entry.probability || '',
                visitProbability: entry.visitProbability || ''
            };
            
            // Add extra fields for activity records
            if (entry.isActivitySegment) {
                result.startTime = entry.startTime;
                result.endTime = entry.endTime;
                result.start_lat = entry.start_lat;
                result.start_lng = entry.start_lng;
                result.end_lat = entry.end_lat; 
                result.end_lng = entry.end_lng;
                result.distance_meters = entry.distance_meters;
                result.activity_type = activityType;
                result.activity_probability = activityConfidence;
            } 
            // Add fields for visit records
            else if (entry.startTime && entry.endTime) {
                result.startTime = entry.startTime;
                result.endTime = entry.endTime;
                
                // Parse the ISO dates for duration calculation
                try {
                    const start = new Date(entry.startTime);
                    const end = new Date(entry.endTime);
                    if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {
                        const durationMs = end - start;
                        result.duration_minutes = (durationMs / 60000).toFixed(2);
                    }
                } catch (e) {
                    console.warn('Error calculating duration:', e);
                }
            }
            
            return result;
        }
        
        /**
         * Extract activities from the processed data
         */
        function extractActivities() {
            // Reset activity data
            activityData = [];
            
            if (processedData.length === 0) {
                return;
            }
            
            // First, include any explicit activity entries from the JSON
            for (const entry of processedData) {
                if (entry.isActivitySegment || entry.activity_type) {
                    try {
                        // Parse ISO dates for proper date objects
                        const startDate = entry.startTime ? new Date(entry.startTime) : new Date(entry.timestamp);
                        const endDate = entry.endTime ? new Date(entry.endTime) : new Date(entry.timestamp);
                        
                        // Format dates for display
                        const formattedStartTime = startDate.toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
                        const formattedEndTime = endDate.toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
                        
                        // Calculate duration in minutes
                        const durationMs = endDate - startDate;
                        const durationMinutes = (durationMs / 60000).toFixed(2);
                        
                        // Calculate distance in kilometers if we have meters
                        const distanceKm = entry.distance_meters ? 
                            (parseFloat(entry.distance_meters) / 1000).toFixed(3) : '';
                        
                        // Calculate speed if we have both duration and distance
                        let speedKph = '';
                        if (distanceKm && durationMinutes > 0) {
                            const durationHours = durationMinutes / 60;
                            speedKph = (parseFloat(distanceKm) / durationHours).toFixed(2);
                        }
                        
                        activityData.push({
                            startTime: formattedStartTime,
                            endTime: formattedEndTime,
                            duration_minutes: durationMinutes,
                            
                            // Location info
                            latitude: entry.latitude,
                            longitude: entry.longitude,
                            municipality: entry.municipality || '',
                            
                            // Activity type from explicit data or derived
                            activity_type: entry.activity_type || 'UNKNOWN',
                            activity_probability: entry.activity_confidence || entry.activity_probability || '100',
                            
                            // Start location
                            start_lat: entry.start_lat || entry.latitude,
                            start_lng: entry.start_lng || entry.longitude,
                            start_municipality: entry.start_municipality || entry.municipality || '',
                            
                            // End location
                            end_lat: entry.end_lat || entry.latitude,
                            end_lng: entry.end_lng || entry.longitude,
                            end_municipality: entry.end_municipality || entry.municipality || '',
                            
                            // Distance metrics
                            distance_meters: entry.distance_meters || '',
                            distance_km: distanceKm,
                            speed_kph: speedKph,
                            
                            // Additional data
                            semanticType: entry.semanticType || '',
                            placeID: entry.placeID || ''
                        });
                    } catch (e) {
                        console.error('Error processing activity entry:', e, entry);
                    }
                }
            }
            
            // Then, derive activities from consecutive location entries
            // Sort data by timestamp for proper sequence
            const sortedData = [...processedData].sort((a, b) => {
                const dateA = a.startTime ? new Date(a.startTime) : new Date(a.timestamp);
                const dateB = b.startTime ? new Date(b.startTime) : new Date(b.timestamp);
                return dateA - dateB;
            });
            
            // Track the previous entry for calculating transitions
            let lastEntry = null;
            
            for (const entry of sortedData) {
                if (lastEntry) {
                    try {
                        // Calculate time difference between entries
                        const startDate = lastEntry.startTime ? new Date(lastEntry.startTime) : new Date(lastEntry.timestamp);
                        const endDate = entry.startTime ? new Date(entry.startTime) : new Date(entry.timestamp);
                        
                        // Only calculate transitions if dates are valid
                        if (!isNaN(startDate.getTime()) && !isNaN(endDate.getTime())) {
                            const durationMs = endDate - startDate;
                            
                            // Only consider transitions within reasonable time (less than 12 hours)
                            if (durationMs > 0 && durationMs < 12 * 60 * 60 * 1000) {
                                const durationMinutes = (durationMs / 60000).toFixed(2);
                                
                                // Calculate distance between points
                                const fromPoint = turf.point([parseFloat(lastEntry.longitude), parseFloat(lastEntry.latitude)]);
                                const toPoint = turf.point([parseFloat(entry.longitude), parseFloat(entry.latitude)]);
                                const distanceKm = turf.distance(fromPoint, toPoint, {units: 'kilometers'});
                                
                                // Only consider meaningful movements (> 100m)
                                if (distanceKm > 0.1) {
                                    // Calculate speed
                                    const speedKph = (distanceKm / (durationMinutes / 60)).toFixed(2);
                                    
                                    // Determine activity type based on speed
                                    let activityType = 'UNKNOWN';
                                    if (speedKph < 7) activityType = 'WALKING';
                                    else if (speedKph < 20) activityType = 'CYCLING';
                                    else activityType = 'IN_VEHICLE';
                                    
                                    // Format timestamps for readability
                                    const formattedStartTime = startDate.toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
                                    const formattedEndTime = endDate.toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');
                                    
                                    // Add to activity data
                                    activityData.push({
                                        startTime: formattedStartTime,
                                        endTime: formattedEndTime,
                                        duration_minutes: durationMinutes,
                                        
                                        // Main location (use start point)
                                        latitude: lastEntry.latitude,
                                        longitude: lastEntry.longitude,
                                        municipality: lastEntry.municipality || '',
                                        
                                        // Activity classification
                                        activity_type: activityType,
                                        activity_probability: '70', // Estimated confidence
                                        
                                        // Start location
                                        start_lat: lastEntry.latitude,
                                        start_lng: lastEntry.longitude,
                                        start_municipality: lastEntry.municipality || '',
                                        start_semanticType: lastEntry.semanticType || '',
                                        
                                        // End location
                                        end_lat: entry.latitude,
                                        end_lng: entry.longitude,
                                        end_municipality: entry.municipality || '',
                                        end_semanticType: entry.semanticType || '',
                                        
                                        // Distance metrics
                                        distance_meters: (distanceKm * 1000).toFixed(0),
                                        distance_km: distanceKm.toFixed(3),
                                        speed_kph: speedKph,
                                        
                                        // Additional data
                                        semanticType: lastEntry.semanticType || '',
                                        placeID: lastEntry.placeID || ''
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error calculating transitions:', e);
                    }
                }
                lastEntry = entry;
            }
            
            // Sort all activities by start time
            activityData.sort((a, b) => {
                const dateA = new Date(a.startTime);
                const dateB = new Date(b.startTime);
                return dateA - dateB;
            });
            
            console.log(`Extracted ${activityData.length} activities from ${processedData.length} location points`);
        }
        
        /**
         * Show preview of data in a table format
         */
        function showPreview(data, container) {
            if (!data || data.length === 0) {
                container.innerHTML = '<div style="padding: 15px; background-color: #fff3e0; border-left: 4px solid #ff9800;">No data available for preview.</div>';
                return;
            }
            
            // Get all unique keys from the data
            const keys = Array.from(new Set(data.flatMap(item => Object.keys(item))));
            
            // Define fields to show based on the output CSV format
            const locationHeaders = ['timestamp', 'latitude', 'longitude',
                                   'country', 'region', 'province', 'municipality', 'semanticType', 'placeID',
                                   'probability', 'visitProbability'];
                                    
            const activityHeaders = ['startTime', 'endTime', 'duration_minutes', 'latitude', 'longitude', 
                                    'municipality', 'activity_type', 'activity_probability', 'distance_km', 
                                    'speed_kph', 'start_lat', 'start_lng', 'end_lat', 'end_lng'];
            
            let dataToShow = data;
            
            // For location history preview, filter out activity entries
            if (container === previewAll) {
                dataToShow = data.filter(entry => !entry.isActivitySegment && !entry.start_lat && !entry.end_lat);
            }
            
            // Use the appropriate headers based on which container we're showing
            const fieldsToShow = container === previewActivities ? 
                activityHeaders.filter(k => keys.includes(k)) : 
                locationHeaders.filter(k => keys.includes(k));
            
            // Create a scrollable wrapper
            let html = '<div style="overflow-x: auto; max-width: 100%;">';
            
            // Create HTML table
            html += '<table>';
            
            // Table header
            html += '<tr>';
            for (const key of fieldsToShow) {
                html += `<th>${key}</th>`;
            }
            html += '</tr>';
            
            // Limit to 50 rows for preview
            const previewLimit = Math.min(50, dataToShow.length);
            
            // Table rows
            for (let i = 0; i < previewLimit; i++) {
                const item = dataToShow[i];
                html += '<tr>';
                for (const key of fieldsToShow) {
                    html += `<td>${item[key] || ''}</td>`;
                }
                html += '</tr>';
            }
            
            html += '</table>';
            html += '</div>'; // Close scrollable wrapper
            
            // Show accurate count of items
            const totalCount = container === previewAll ? 
                processedData.filter(entry => !entry.isActivitySegment && !entry.start_lat && !entry.end_lat).length : 
                activityData.length;
            
            html += `<p><em>Showing ${previewLimit} of ${totalCount} entries.</em></p>`;
            
            container.innerHTML = html;
        }
        
        /**
         * Download data as CSV file
         */
        function downloadCSV(data, filename) {
            if (!data || data.length === 0) {
                status.textContent = 'No data to download.';
                status.className = 'info-box warning';
                return;
            }
            
            let csvData;
            let filteredData;
            
            if (filename.includes('activity')) {
                // For activity data, use the activity-specific format
                const activityHeaders = 'startTime,endTime,duration_minutes,latitude,longitude,municipality,activity_type,activity_probability,start_lat,start_lng,start_municipality,start_semanticType,end_lat,end_lng,end_municipality,end_semanticType,distance_meters,distance_km,speed_kph,placeID,semanticType';
                filteredData = data;
                csvData = formatCSV(filteredData, activityHeaders.split(','));
                filename = 'location-activity-data.csv';
            } else {
                // For location history, use only pure location data columns (no activity-specific fields)
                // Filter out any entries that are activity segments
                filteredData = data.filter(entry => !entry.isActivitySegment && !entry.start_lat && !entry.end_lat);
                
                // Pure location history headers - add probability and visitProbability
                const locationHeaders = 'timestamp,latitude,longitude,country,region,province,municipality,placeID,semanticType,probability,visitProbability';
                csvData = formatCSV(filteredData, locationHeaders.split(','));
                filename = 'location-history.csv';
            }
            
            // Create download link
            const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            status.textContent = `Downloaded ${filteredData.length} entries to ${filename}.`;
            status.className = 'info-box success';
        }
        
        /**
         * Format data as CSV with specific headers
         */
        function formatCSV(data, headers) {
            // Create CSV header
            let csv = headers.join(',') + '\n';
            
            // Add data rows
            for (const item of data) {
                const row = headers.map(header => {
                    const value = item[header] || '';
                    
                    // Quote values with commas
                    return value.toString().includes(',') ? 
                        `"${value}"` : value;
                }).join(',');
                
                csv += row + '\n';
            }
            
            return csv;
        }
        
        /**
         * Toggle a collapsible section
         */
        function toggleSection(sectionId, toggleId) {
            const section = document.getElementById(sectionId);
            const toggle = document.getElementById(toggleId);
            
            section.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
        }
    </script>
</body>
</html> 